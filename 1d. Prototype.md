# Prototype
The Prototype Design Pattern is a creational design pattern that allows you to create new objects by copying existing objects, known as prototypes, without the need for explicitly invoking constructors. The prototype serves as a blueprint for creating new objects, and the pattern is useful when creating objects is complex or costly.

In the context of the `Vehicle` and `Car` example, the Prototype Design Pattern would involve creating a prototype object (e.g., an existing `Car` instance) and then creating new `Car` objects by copying the prototype. This approach avoids the need for repeatedly constructing new objects from scratch, which can be expensive or involve complex initialization logic.
![image](https://github.com/boushphong/Design-Patterns/assets/59940078/8e0047e5-2eee-4b29-9f53-932e601953e6)

```java
import java.util.Objects;

class Vehicle implements Cloneable {
    private String brand;
    private String model;
    private int year;

    public Vehicle(String brand, String model, int year) {
        this.brand = brand;
        this.model = model;
        this.year = year;
    }

    // Getter and Setter

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;  // Same Class or o == null then continue
        Vehicle vehicle = (Vehicle) o;
        return year == vehicle.year && brand.equals(vehicle.brand) && model.equals(vehicle.model);
    }

    @Override
    public int hashCode() {
        return Objects.hash(brand, model, year);
    }

    @Override
    public Vehicle clone() {
        try {
            return (Vehicle) super.clone();
        } catch (CloneNotSupportedException e) {
            // Handle the exception, if necessary
            return null;
        }
    }

    @Override
    public String toString() {
        return "Vehicle{" +
                "brand='" + brand + '\'' +
                ", model='" + model + '\'' +
                ", year=" + year +
                '}';
    }
}

public class Main {
    public static void main(String[] args) {
        Vehicle carPrototype = new Vehicle("Toyota", "Camry", 2022);
        Vehicle car1 = carPrototype.clone();
        Vehicle car2 = carPrototype.clone();

        car1.setModel("Corolla");
        car2.setYear(2023);

        System.out.println(car1);  // Vehicle{brand='Toyota', model='Corolla', year=2022}
        System.out.println(car2);  // Vehicle{brand='Toyota', model='Camry', year=2023}
    }
}
```
In this example, we have a `Vehicle` class that serves as the prototype for creating new `Car` objects. The `Vehicle` class implements the `Cloneable` interface, which allows us to create copies of the prototype using the `clone` method.

The `Vehicle` class contains the common properties like brand, model, and year. It provides getter and setter methods to access and modify these properties.

The `clone` method is overridden to provide a shallow copy of the `Vehicle` object. It invokes the `clone` method of the superclass (`Object`) and casts the result to the `Vehicle` type.

In the `Main` class, we create a `carPrototype` object, which acts as the prototype for new `Car` objects. We create two new `Car` objects (`car1` and `car2`) by cloning the `carPrototype`.

We then modify the properties of `car1` and `car2` and print both objects out.


## Prototype Design Pattern Summary
- Use the Prototype pattern when your code shouldn’t depend on the concrete classes of objects that you need to copy.
    - This happens a lot when your code works with objects passed to you from 3rd-party code via some interface. The concrete classes of these objects are unknown, and you couldn’t depend on them even if you wanted to.
    - The Prototype pattern provides the client code with a general interface for working with all objects that support cloning. This interface makes the client code independent from the concrete classes of objects that it clones.
- Use the pattern when you want to reduce the number of subclasses that only differ in the way they initialize their respective objects. Somebody could have created these subclasses to be able to create objects with a specific configuration.
    - The Prototype pattern lets you use a set of pre-built objects, configured in various ways, as prototypes.
    - Instead of instantiating a subclass that matches some configuration, the client can simply look for an appropriate prototype and clone it.

## Note
The `clone` method of the `Object` class in Java performs a shallow copy of the object by creating a new instance of the same class and copying the field values from the original object to the new object. It does not invoke the constructor of the class being cloned.

`java/lang/Object.class` is implemented as:
```java
protected native Object clone() throws CloneNotSupportedException;
```

The `clone` method is declared as `protected` in the `Object` class and is native, which means its implementation is provided by the underlying JVM.

When you implement the `Cloneable` interface in your own class and override the `clone` method, the default implementation in the `Object` class provides the basic functionality of creating a new instance and copying the field values.

However, it's important to note that the default implementation of `clone` in the `Object` class performs a shallow copy. This means that if the object being cloned contains references to other objects, those references are copied to the new object. As a result, both the original and cloned objects will reference the same objects, which can lead to unexpected behavior if the referenced objects are mutable.

If you require a deep copy, where all referenced objects are also cloned, you need to override the `clone` method in your class and manually perform the deep copy logic.

It's worth mentioning that the `clone` method has some limitations and considerations, and it's generally recommended to use other mechanisms, such as copy constructors or the `clone` method from the `Cloneable` interface, to achieve object cloning in a more controlled and consistent manner.
