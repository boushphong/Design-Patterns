# Mediator
The Mediator pattern is used to simplify the communication between objects in a system by introducing a mediator object that encapsulates how these objects interact with each other.

![image](https://github.com/boushphong/Design-Patterns/assets/59940078/dc3436d3-0a58-42a6-9230-2f8c5a5f9ed5)

```java
import java.util.ArrayList;
import java.util.List;

// Mediator interface
interface TrafficControlMediator {
    void registerVehicle(Vehicle vehicle);
    void notifyVehicleReady(Vehicle vehicle);
    void notifyVehicleDeparture(Vehicle vehicle);
}

// Concrete mediator class: TrafficControlTower
class TrafficControlTower implements TrafficControlMediator {
    private List<Vehicle> vehicles;

    public TrafficControlTower() {
        vehicles = new ArrayList<>();
    }

    @Override
    public void registerVehicle(Vehicle vehicle) {
        vehicles.add(vehicle);
    }

    @Override
    public void notifyVehicleReady(Vehicle vehicle) {
        System.out.println("Traffic Control Tower: Vehicle " + vehicle.getVehicleName() + " is ready.");
        // Perform any necessary coordination logic, e.g., granting permission to depart
    }

    @Override
    public void notifyVehicleDeparture(Vehicle vehicle) {
        System.out.println("Traffic Control Tower: Vehicle " + vehicle.getVehicleName() + " has departed.");
    }
}

// Colleague interface
interface Vehicle {
    void setMediator(TrafficControlMediator mediator);
    void ready();
    void depart();
    String getVehicleName();
}

// Concrete colleague class: Car
class Car implements Vehicle {
    private String name;
    private TrafficControlMediator mediator;

    public Car(String name) {
        this.name = name;
    }

    @Override
    public void setMediator(TrafficControlMediator mediator) {
        this.mediator = mediator;
    }

    @Override
    public void ready() {
        System.out.println(name + ": Car is ready to depart.");
        mediator.notifyVehicleReady(this);
    }

    @Override
    public void depart() {
        System.out.println(name + ": Car is departing.");
        mediator.notifyVehicleDeparture(this);
    }

    @Override
    public String getVehicleName() {
        return name;
    }
}

// Concrete colleague class: Truck
class Truck implements Vehicle {
    private String name;
    private TrafficControlMediator mediator;

    public Truck(String name) {
        this.name = name;
    }

    @Override
    public void setMediator(TrafficControlMediator mediator) {
        this.mediator = mediator;
    }

    @Override
    public void ready() {
        System.out.println(name + ": Truck is ready to depart.");
        mediator.notifyVehicleReady(this);
    }

    @Override
    public void depart() {
        System.out.println(name + ": Truck is departing.");
        mediator.notifyVehicleDeparture(this);
    }

    @Override
    public String getVehicleName() {
        return name;
    }
}

public class Main {
    public static void main(String[] args) {
        TrafficControlMediator trafficControlTower = new TrafficControlTower();

        Vehicle car = new Car("Car 1");
        Vehicle truck = new Truck("Truck 1");

        car.setMediator(trafficControlTower);
        truck.setMediator(trafficControlTower);

        trafficControlTower.registerVehicle(car);
        trafficControlTower.registerVehicle(truck);

        // Car and truck ready to depart
        car.ready();
        truck.ready();

        // Car and truck depart
        car.depart();
        truck.depart();
    }
}
```

In this example, We define the `TrafficControlMediator` interface. This interface declares the methods `registerVehicle()`, `notifyVehicleReady()`, and `notifyVehicleDeparture()`. These methods define the communication protocol between the mediator and the vehicles. We implement the `TrafficControlTower` class, which serves as the concrete mediator. It maintains a list of registered vehicles and implements the mediator methods. The `registerVehicle()` method adds a vehicle to the list, `notifyVehicleReady()` notifies the tower that a vehicle is ready to depart, and `notifyVehicleDeparture()` informs the tower that a vehicle has departed.

3. We define the `Vehicle` interface, which represents the colleagues (vehicles) that communicate through the mediator. It declares the methods `setMediator()`, `ready()`, `depart()`, and `getVehicleName()`.

4. We implement the `Car` class, which is a concrete colleague. It has a name and a reference to the mediator. The `setMediator()` method sets the mediator reference, `ready()` informs the mediator that the car is ready to depart, `depart()` notifies the mediator that the car has departed, and `getVehicleName()` returns the car's name.

5. Similarly, we implement the `Truck` class as another concrete colleague. It has similar methods to the `Car` class.

6. Finally, in the `Main` class, we create a `TrafficControlTower` object and create instances of `Car` and `Truck`. We set the mediator for each vehicle and register them with the tower. Then, we simulate the vehicles being ready to depart and actually departing by calling the `ready()` and `depart()` methods.

The mediator pattern allows vehicles (colleagues) to communicate through the mediator (traffic control tower) without knowing each other directly. The tower handles the coordination and communication between the vehicles, enabling a decoupled and flexible system.
