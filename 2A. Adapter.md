# Adapter
The Adapter Design Pattern allows objects with incompatible interfaces to work together by providing a wrapper or adapter class that acts as a bridge between them. It converts the interface of one class into another interface that clients expect.

```java
// Vehicle interface
interface Vehicle {
    void accelerate();
    void brake();
}

// Car class implementing Vehicle interface
class Car implements Vehicle {
    @Override
    public void accelerate() {
        System.out.println("Car: Accelerating");
    }

    @Override
    public void brake() {
        System.out.println("Car: Braking");
    }
}

// ToyCar interface
interface RemoteControlToy {
    void moveForward();
    void stop();
}

// ToyCar class implementing ToyCar interface
class ToyCar implements RemoteControlToy {
    @Override
    public void moveForward() {
        System.out.println("ToyCar: Moving forward");
    }

    @Override
    public void stop() {
        System.out.println("ToyCar: Stopping");
    }
}

// Adapter class that adapts ToyCar to Vehicle interface
class ToyCarAdapter implements Vehicle {
    private RemoteControlToy toyCar;

    public ToyCarAdapter(RemoteControlToy toyCar) {
        this.toyCar = toyCar;
    }

    @Override
    public void accelerate() {
        toyCar.moveForward();
    }

    @Override
    public void brake() {
        toyCar.stop();
    }
}

public class Main {
    public static void main(String[] args) {
        // Create a Car object
        Car car = new Car();

        // Create a ToyCar object
        RemoteControlToy toyCar = new ToyCar();

        // Create a ToyCarAdapter object, which acts as an adapter
        Vehicle toyCarAdapter = new ToyCarAdapter(toyCar);

        // Use the Car object
        car.accelerate();
        car.brake();

        // Use the ToyCarAdapter object
        toyCarAdapter.accelerate();
        toyCarAdapter.brake();
    }
}
```

In this example, we have the `Vehicle` interface representing the common interface for vehicles, which includes methods like `accelerate` and `brake`. The `Car` class implements the `Vehicle` interface and represents a real car with its own implementations of the methods.

The `RemoteControlToy` interface represents a toy car and has its own methods `moveForward` and `stop`. The `ToyCar` class implements the `RemoteControlToy` interface and represents a specific type of toy car with its own implementations of the methods.

The `ToyCarAdapter` class adapts the `RemoteControlToy` interface to the `Vehicle` interface. It takes a `ToyCar` object in its constructor and provides implementations of the `accelerate` and `brake` methods by delegating the calls to the corresponding methods of the `ToyCar` object.

# Adater Design Pattern Summary
- Use the Adapter class when you want to use some existing class, but its interface isn’t compatible with the rest of your code.
    - The Adapter pattern lets you create a middle-layer class that serves as a translator between your code and a legacy class, a 3rd-party class or any other class with a weird interface.
        - Allows objects with incompatible interfaces, such as the `Vehicle` interface and the `ToyCar` interface, to work together by providing an adapter that converts the interface of one object to the interface expected by the client.
- Use the pattern when you want to reuse several existing subclasses that lack some common functionality that can’t be added to the superclass.
    - You could extend each subclass and put the missing functionality into new child classes. However, you’ll need to duplicate the code across all of these new classes, which smells really bad.
        - Solution: The much more elegant solution would be to put the missing functionality into an adapter class. Then you would wrap objects with missing features inside the adapter, gaining needed features dynamically. For this to work, the target classes must have a common interface, and the adapter’s field should follow that interface. This approach looks very similar to the Decorator pattern.
